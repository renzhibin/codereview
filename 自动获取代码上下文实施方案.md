# 自动获取代码上下文实施方案（优化版）

## 核心目标

当检测到**安全相关的代码改动**时，自动获取完整代码上下文（源文件、调用链、相关类），提交给LLM进行更准确的安全评审，但最终只返回diff代码的问题给用户。

## 技术方案

### 1. 判断是否需要上下文（LLM智能判断）⭐

创建 `biz/utils/context_detector.py`，调用LLM快速判断：

**工作流程：**
1. 提取diff代码的关键信息（类名、方法名、注解、修改内容摘要）
2. 使用轻量级LLM调用快速判断（使用较低的temperature=0提高稳定性）
3. 提示词设计：

```python
CONTEXT_DETECTION_PROMPT = """你是代码安全分析专家。判断以下Java代码改动是否需要获取完整代码上下文来进行安全评审。

需要上下文的场景：
- 权限控制相关（@PreAuthorize、@PostAuthorize、@Secured、授权、鉴权）
- 数据库操作（SQL、JPA、MyBatis，可能存在SQL注入、越权访问）
- 文件操作（File、Path、FileInputStream等，可能存在路径遍历）
- 敏感数据处理（用户信息、订单、支付、账户等业务）
- Controller层的增删改操作（@PostMapping、@PutMapping、@DeleteMapping）
- Service层调用了其他服务方法（需要理解完整业务流程）
- 涉及敏感配置的修改

不需要上下文的场景：
- 纯配置文件修改（.properties、.yml）
- 注释、文档修改
- 日志输出语句
- 简单的getter/setter方法
- 纯工具类方法（字符串处理、日期格式化等）
- 单元测试代码

代码改动摘要：
{diff_summary}

请直接回答：需要 或 不需要
只输出这两个词之一，不要有其他内容。
"""
```

**优势：**
- 更智能，能识别复杂的安全场景（如Service层的业务方法）
- 可以理解业务语义，不只是关键词匹配
- 减少误判（如注释中包含"权限"等关键词不会误触发）

### 2. Git仓库管理策略（优化大仓库）⭐

创建 `biz/utils/git_manager.py`，实现智能仓库管理：

**克隆策略（针对大仓库优化）：**
```python
class GitManager:
    def ensure_repo(self, repo_url, branch, project_name, access_token):
        """确保本地有指定分支的仓库，使用缓存策略"""
        repo_path = self._get_cache_path(project_name, branch)
        
        if os.path.exists(repo_path):
            # 增量更新：fetch + reset
            self._update_repo(repo_path, branch)
        else:
            # 浅克隆：只克隆单个分支，深度为1
            self._clone_repo(repo_url, branch, repo_path, access_token)
        
        self._update_cache_metadata(project_name, branch)
        return repo_path
    
    def _clone_repo(self, repo_url, branch, repo_path, access_token):
        """浅克隆仓库"""
        # 在URL中注入access_token
        auth_url = self._inject_token(repo_url, access_token)
        cmd = [
            'git', 'clone',
            '--depth=1',                    # 只克隆最新提交
            '--single-branch',              # 只克隆单个分支
            '--branch', branch,
            auth_url,
            repo_path
        ]
        subprocess.run(cmd, check=True, capture_output=True)
    
    def _update_repo(self, repo_path, branch):
        """增量更新已存在的仓库"""
        subprocess.run(['git', 'fetch', 'origin', branch], cwd=repo_path)
        subprocess.run(['git', 'reset', '--hard', f'origin/{branch}'], cwd=repo_path)
```

**缓存管理：**
- 缓存路径：`data/repos/{project_slug}/{branch}/`
- 元数据：`data/repos_cache.json` 记录每个仓库的最后访问时间
- 自动清理：可选功能，删除超过30天未使用的缓存

**Git凭证处理：**
```python
def _inject_token(self, repo_url, access_token):
    """在Git URL中注入access token"""
    # GitLab: https://oauth2:{token}@gitlab.com/user/repo.git
    # GitHub: https://{token}@github.com/user/repo.git
    parsed = urlparse(repo_url)
    if 'gitlab' in parsed.netloc:
        auth = f'oauth2:{access_token}'
    else:
        auth = access_token
    return f"{parsed.scheme}://{auth}@{parsed.netloc}{parsed.path}"
```

### 3. Java代码上下文分析（使用JavaParser）⭐

**方案：在AI-Codereview-Gitlab项目内创建独立的Java工具**

在 `AI-Codereview-Gitlab/java-tools` 目录创建独立的Maven项目：
- `java-tools/pom.xml` - Maven配置文件
- `java-tools/src/main/java/com/codereview/ContextExtractor.java` - 上下文提取工具

**Python侧集成（`biz/utils/java_context_analyzer.py`）：**
通过subprocess调用Java工具，解析返回的JSON，格式化为LLM友好的文本格式。

### 4. 提示词修改

修改 `conf/prompt_templates.yml`，在 `code_review_prompt` 中增加上下文处理说明：

**关键点：**
- 明确区分【评审代码（diff）】和【代码上下文】
- 强调只对diff部分提问题
- 利用上下文判断安全漏洞的真实性

### 5. 集成到评审流程

修改 `biz/utils/code_reviewer.py`，集成上下文获取流程：

**流程：**
1. 检查是否启用上下文功能（环境变量）
2. 使用LLM判断是否需要上下文
3. 如果需要，克隆/更新仓库
4. 使用JavaParser分析上下文
5. 将上下文和diff一起提交给LLM评审

### 6. 修改worker调用

修改 `biz/queue/worker.py`，传递仓库URL、分支等信息给CodeReviewer。

## 实施步骤

### 第一阶段：基础设施
1. 创建 `git_manager.py` - Git仓库管理（浅克隆+缓存）
2. 测试Git克隆和增量更新机制

### 第二阶段：上下文判断
3. 创建 `context_detector.py` - LLM智能判断是否需要上下文
4. 测试判断准确性（准备测试用例）

### 第三阶段：Java分析工具
5. 创建 `java-tools` 目录和Maven项目
6. 开发 `ContextExtractor.java` - Java上下文提取工具
7. 创建 `java_context_analyzer.py` - Python集成
8. 测试上下文提取的完整性和准确性

### 第四阶段：集成
9. 修改 `code_reviewer.py` - 集成上下文获取流程
10. 修改 `prompt_templates.yml` - 更新提示词
11. 修改 `worker.py` - 传递仓库信息

### 第五阶段：优化和测试
12. Token计数和截断策略（上下文+diff不超限）
13. 错误处理和降级机制
14. 性能优化和端到端测试

## 关键设计决策

1. **LLM智能判断是否需要上下文** ⭐：比关键词匹配更准确，能理解业务语义和Service层方法
2. **使用JavaParser而非javalang** ⭐：官方解析器准确性更高，避免解析错误
3. **浅克隆 + 增量更新**：针对大仓库优化，节省时间和空间
4. **缓存策略**：常用分支保留，减少重复克隆
5. **提示词分段强调**：明确区分评审代码和上下文，避免对上下文提问题
6. **降级机制**：获取上下文失败时，仍然进行正常评审
7. **两次LLM调用**：
   - 第一次：快速判断是否需要上下文（低成本、低延迟）
   - 第二次：完整评审（高质量、带上下文）

## 目录结构变化

```
AI-Codereview-Gitlab/
├── biz/
│   └── utils/
│       ├── context_detector.py         # 新增：LLM判断是否需要上下文
│       ├── git_manager.py              # 新增：Git仓库管理
│       ├── java_context_analyzer.py    # 新增：调用JavaParser
│       └── code_reviewer.py            # 修改：集成上下文
├── conf/
│   └── prompt_templates.yml            # 修改：更新提示词
├── data/
│   ├── repos/                          # 新增：Git仓库缓存
│   │   └── {project_slug}/
│   │       └── {branch}/
│   └── repos_cache.json                # 新增：缓存元数据
├── java-tools/                         # 新增：Java工具目录
│   ├── pom.xml                         # Maven配置
│   ├── README.md                       # 使用说明
│   └── src/main/java/com/codereview/
│       └── ContextExtractor.java       # 上下文提取工具
└── requirements.txt                    # 无需修改
```

## 配置项（环境变量）

```bash
# 是否启用上下文获取（默认关闭）
CONTEXT_ENABLED=1

# 仓库缓存目录
REPOS_CACHE_DIR=data/repos

# 缓存清理阈值（天）
REPOS_CACHE_EXPIRE_DAYS=30

# 上下文最大Token数
CONTEXT_MAX_TOKENS=20000

# LLM判断超时时间（秒）
CONTEXT_DETECTION_TIMEOUT=5
```

## 注意事项

1. **原则：老代码不改**，只新增功能模块和可选参数
2. **Git凭证安全**：在URL中注入token，避免凭证泄露
3. **Token限制管理**：
   - 上下文提取后需要计算token数
   - 如果上下文+diff超限，优先保留diff，截断上下文
   - 或者只提取关键类文件，不包含所有依赖
4. **错误处理**：网络问题、Git权限、JavaParser失败都需要优雅降级
5. **性能考虑**：
   - LLM判断增加5-10秒
   - Git克隆首次可能需要30-60秒（大仓库）
   - 增量更新通常只需5-10秒
   - JavaParser分析通常1-3秒
6. **安全性**：
   - 仓库缓存目录权限控制
   - access_token不要写入日志
   - 定期清理缓存避免磁盘占满

